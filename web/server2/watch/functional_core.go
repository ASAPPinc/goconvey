package watch

import (
	"os"
	"path/filepath"
	"strings"

	"github.com/smartystreets/goconvey/web/server2/messaging"
)

///////////////////////////////////////////////////////////////////////////////

func Categorize(items chan FileSystemItem) (folders, profiles, goFiles []FileSystemItem) {
	for item := range items {
		if item.IsFolder && !isHidden(item.Name) && !foundInHiddenDirectory(item) {
			folders = append(folders, item)

		} else if strings.HasSuffix(item.Name, ".goconvey") && len(item.Name) > len(".goconvey") {
			profiles = append(profiles, item)

		} else if strings.HasSuffix(item.Name, ".go") && !isHidden(item.Name) && !foundInHiddenDirectory(item) {
			goFiles = append(goFiles, item)

		}
	}
	return folders, profiles, goFiles
}
func foundInHiddenDirectory(item FileSystemItem) bool {
	for _, folder := range strings.Split(filepath.Dir(item.Path), slash) {
		if isHidden(folder) {
			return true
		}
	}
	return false
}
func isHidden(path string) bool {
	return strings.HasPrefix(path, ".")
}

const slash = string(os.PathSeparator)

///////////////////////////////////////////////////////////////////////////////

type Profile struct {
	Path      string
	Disabled  bool
	TestFlags []string
}

func ParseProfiles(profiles map[string]string) []Profile {
	parsed := []Profile{}

	for path, content := range profiles {
		isDisabled, arguments := parseProfile(content)
		parsed = append(parsed, Profile{
			Path:      path,
			Disabled:  isDisabled,
			TestFlags: arguments,
		})
	}

	return parsed
}
func parseProfile(profile string) (isDisabled bool, arguments []string) {
	lines := strings.Split(profile, "\n")
	arguments = []string{}

	for _, line := range lines {
		line = strings.TrimSpace(line)

		if len(arguments) == 0 && strings.ToLower(line) == "ignore" {
			return true, []string{}

		} else if len(line) == 0 {
			continue

		} else if strings.HasPrefix(line, "#") {
			continue

		} else if strings.HasPrefix(line, "//") {
			continue

		} else if strings.HasPrefix(line, "-cover") {
			continue // TODO: enable custom coverage flags...

		} else if line == "-v" {
			continue // Verbose mode is always enabled so there is no need to record it here.

		}

		arguments = append(arguments, line)
	}

	return false, arguments
}

///////////////////////////////////////////////////////////////////////////////

func CreateFolders(folders, goFiles []FileSystemItem, profiles []Profile) []messaging.Folder {
	return nil
}

///////////////////////////////////////////////////////////////////////////////

func FilterDepth(folders []messaging.Folder, depth int) []messaging.Folder {
	return folders
}

///////////////////////////////////////////////////////////////////////////////

func FlagIgnored(folders []messaging.Folder, ignored map[string]struct{}) []messaging.Folder {
	return folders
}

///////////////////////////////////////////////////////////////////////////////

func Checksum(folders []messaging.Folder) int64 {
	return -1
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// func LimitDepth(items []FileSystemItem, depth int) []FileSystemItem {
// 	if depth < 0 {
// 		return items
// 	}

// 	filtered := []FileSystemItem{}
// 	for _, item := range items {
// 		nested := item.Path[len(item.Root):]
// 		if strings.Count(nested, slash) <= depth {
// 			filtered = append(filtered, item)
// 		}
// 	}

// 	return filtered
// }

// const slash = string(os.PathSeparator)

// ///////////////////////////////////////////////////////////////////////////////

// func LimitIgnored(items []FileSystemItem, ignored []string) []FileSystemItem {
// 	if len(ignored) == 0 {
// 		return items
// 	}
// 	filtered := []FileSystemItem{}
// 	for _, item := range items {
// 		if !shouldIgnore(item, ignored) {
// 			filtered = append(filtered, item)
// 		}

// 	}
// 	return filtered
// }
// func shouldIgnore(item FileSystemItem, ignored []string) bool {
// 	for _, ignored := range ignored {
// 		if strings.HasPrefix(item.Path, ignored) {
// 			return true
// 		}
// 	}
// 	return false
// }

// ///////////////////////////////////////////////////////////////////////////////

// func Checksum(items []FileSystemItem) int64 {
// 	var sum int64

// 	for _, item := range items {
// 		if item.IsFolder && strings.HasPrefix(item.Name, ".") {
// 			continue
// 		}

// 		if item.IsFolder {
// 			sum++
// 			continue
// 		}

// 		extension := filepath.Ext(item.Path)

// 		if extension != ".go" && extension != ".goconvey" {
// 			continue
// 		}

// 		if strings.HasPrefix(item.Name, ".") {
// 			continue
// 		}

// 		if strings.HasPrefix(filepath.Base(filepath.Dir(item.Path)), ".") {
// 			continue
// 		}

// 		sum += item.Size + item.Modified
// 	}

// 	return sum
// }

// ///////////////////////////////////////////////////////////////////////////////
